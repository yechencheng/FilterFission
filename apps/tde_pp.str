/*****************************************************************************/
/* TDE stage in GMTI with data from SmallModel

   By Jinwoo Suh (ISI-East)
      email: jsuh@isi.edu
   On 10/12/05

 - TDE stage performs frequency doamin convolution.
 - Currently, it is not well optimized. More work to do.


 Modified by Allyn Dimock May 2006 from Jinwoo's old revision 1.3 which
 was pipeline-parallel:  
 -  Replaced Jinwoo's FFT which was not working at that time and replaced with 
    vanilla FFT from our FFT2 code.
 -  Made amount of data-parallelism tunable.
 -  Removed unreferenced answer array (which can be found in a C version in
    the /projects/raw/cvsroot CVS Repository as 
    starsearch/end-to-end/isi/svm/RSTREAM-TEST/GMTI/refeq.c)

 A steady-state of this code should have 0 inputs and produce 6480 float
 outputs (3240 complex values).

 The algorithm is a simple convolution.

*/
 /*****************************************************************************/

void->void pipeline tde_pp {	// pipeline-parallel tde

	/* The number of channels or sensors receiving data. */
    int CH = 6; // N_CH in C Code. 
    /* The number of range (distance from antenna) gates. */
    int N = 36; // number of input samples  (N_RG in C Code)
    /* Pulse repetition intervals per data cube */
    int M = 15; // number of pri's in a  (N_PRI in C Code)
    int B = 1<<20; // smallest power of 2 above N
                // Data is [N_CH][N_RG][N_PRI][2]
    float mult = 0.00390625; // multiplier
    int DataParallelism = 1; // any number 0 < DataParallelism <= N
    int FFTDataParallelism = 1; // any number < number of DFTs calculated 

    // CH * M gives you the whole source for a single iteration
    //add source (CH * M); 
    add FileReader<float>("../input/tde_pp.in");

    add Transpose(N, M);

    if (DataParallelism == 1) {
	// Redundant, for versions of the compiler that do not 
	// optimize away a splitjoint that does nothing.
    	add pipeline {
	    add Expand(N, B);	                   // up to power of 2 for fft
	    add FFTKernel4(B, FFTDataParallelism); // fft
	    add Multiply_by_float(B, mult);        // mult 
	    add IFFTKernel4(B, FFTDataParallelism);// ifft
	    add Contract(N, B);                    // back to original size
	}
} else {
	/*
	// Same as above with data-parallelism.
	add splitjoin {
		split roundrobin(2);
		for (int i=0; i<DataParallelism; i++) {
			add pipeline {
				add Expand(N, B);
				add FFTKernel4(B, FFTDataParallelism);
				add Multiply_by_float(B, mult);
				add IFFTKernel4(B, FFTDataParallelism);
				add Contract(N, B);
			}
		}
		join roundrobin(2);
	}
	*/
}
add Transpose(M, N);
add FileWriter<float>("tde_pp.out");
    //add sink(CH * M);

}
/*

float->float filter PassF(){
	work pop 1 push 1{
		push(pop());
	}
}

float->void filter DropF(){
	work pop 1{
		pop();
	}
}

void->float filter GenF(){
	work push 1{
		push(0);
	}
}


float->float splitjoin Contract(int N, int B){
	split roundrobin(2*N, 2*(B-N));
	add PassF();
	add DropF();
	join roundrobin(2*N, 0);
}

float->float splitjoin Expand(int N, int B){
	split roundrobin(2*N, 0);
	add PassF();
	add GenF();
	join roundrobin(2*N, 2*(B-N));
}
*/

float->float filter Contract(int N, int B) {
  float x;
  work pop 2*B push 2*N {
   for (int i = 0; i < 2*N; i++) {
    push(pop());
  }
  for (int i = 2*N; i < 2*B; i++) {
    pop(); 
  }
}
}

// expand data for next-largest power of 2 (known to be 64)
float->float filter Expand(int N, int B) {
  work pop 2*N push 2*B {
   for (int i = 0; i < 2*N; i++) {
    float x = pop();
    push(x);
  }
  for (int i = 2*N; i < 2*B; i++) {
    push(0.0);
  }
}
}


float->float filter Multiply_by_float(int B, float m) {
	work pop 8 push 8 { 
		for (int j = 0; j < 8; j++) {
			push(pop() * m);
		}
	}
}

// Transpose written as a filter.
// A future optimization could be to combine Transpose with source.
//
// The Transpose at the end can be eliminated if you are going on to
// other phases of the GMTI program with this data and can masage their
// data requirements appropriately.
float->float filter Transpose(int M, int N) {
	work push M*N*2 peek M*N*2 pop M*N*2 {
		for(int i=0; i<M; i++) {
			for(int j=0; j<N; j++) {
				push(peek(i*N*2+j*2));
				push(peek(i*N*2+j*2+1));
			}
		}
		for(int i=0; i<M; i++) {
			for(int j=0; j<N; j++) {
				pop();
				pop();
			}
		}
	}
}
/*
float->float filter Transpose(int M, int N) {
	work pop 8 push 8{
		for(int i = 0; i < 8; i++)
			push(pop());
	}
}*/

/*
float->float filter Transpose(int M, int N) {
    work push M*N*2 peek M*N*2 pop M*N*2 {
        for(int i=0; i<M; i++) {
            for(int j=0; j<N; j++) {
                push(peek(i*N*2+j*2));
                push(peek(i*N*2+j*2+1));
            }
        }
        for(int i=0; i<M; i++) {
            for(int j=0; j<N; j++) {
                pop();
                pop();
            }
        }
    }
}
*/

float->void filter sink (int m) {

	float x, diff;
	int correct = 1;

	work pop 36 * 2 * m { 
		for (int i=0; i<m; i++) {
			for (int j=0; j<36; j++) {
				println(pop());
				println(pop());
			}
		}
	}
}
