/*****************************************************************************/
/* TDE stage in GMTI with data from SmallModel

   By Jinwoo Suh (ISI-East)
      email: jsuh@isi.edu
   On 10/12/05

 - TDE stage performs frequency doamin convolution.
 - Currently, it is not well optimized. More work to do.


 Modified by Allyn Dimock May 2006 from Jinwoo's old revision 1.3 which
 was pipeline-parallel:  
 -  Replaced Jinwoo's FFT which was not working at that time and replaced with 
    vanilla FFT from our FFT2 code.
 -  Made amount of data-parallelism tunable.
 -  Removed unreferenced answer array (which can be found in a C version in
    the /projects/raw/cvsroot CVS Repository as 
    starsearch/end-to-end/isi/svm/RSTREAM-TEST/GMTI/refeq.c)

 A steady-state of this code should have 0 inputs and produce 6480 float
 outputs (3240 complex values).

 The algorithm is a simple convolution.

*/
 /*****************************************************************************/

void->void pipeline tde_pp {	// pipeline-parallel tde

	/* The number of channels or sensors receiving data. */
    int CH = 6; // N_CH in C Code. 
    /* The number of range (distance from antenna) gates. */
    int N = 36; // number of input samples  (N_RG in C Code)
    /* Pulse repetition intervals per data cube */
    int M = 15; // number of pri's in a  (N_PRI in C Code)
    int B = 128; // smallest power of 2 above N
                // Data is [N_CH][N_RG][N_PRI][2]
    float mult = 0.00390625; // multiplier
    int DataParallelism = 1; // any number 0 < DataParallelism <= N
    int FFTDataParallelism = 1; // any number < number of DFTs calculated 

    // CH * M gives you the whole source for a single iteration
    //add source (CH * M); 
    add FileReader<float>("../input/tde_pp.in");

    add Transpose(N, M);

    if (DataParallelism == 1) {
	// Redundant, for versions of the compiler that do not 
	// optimize away a splitjoint that does nothing.
    	add pipeline {
	    add Expand(N, B);	                   // up to power of 2 for fft
	    add FFTKernel4(B, FFTDataParallelism); // fft
	    add Multiply_by_float(B, mult);        // mult 
	    add IFFTKernel4(B, FFTDataParallelism);// ifft
	    add Contract(N, B);                    // back to original size
	}
} else {
	// Same as above with data-parallelism.
	add splitjoin {
		split roundrobin(2);
		for (int i=0; i<DataParallelism; i++) {
			add pipeline {
				add Expand(N, B);
				add FFTKernel4(B, FFTDataParallelism);
				add Multiply_by_float(B, mult);
				add IFFTKernel4(B, FFTDataParallelism);
				add Contract(N, B);
			}
		}
		join roundrobin(2);
	}
}
add Transpose(M, N);
add FileWriter<float>("tde_pp.out");
    //add sink(CH * M);

}



float->float pipeline FFTKernel4(int B, int FFTDataParallelism) {
  int N = B;

  add FFTReorder(N);
  add Fused_CombineDFT(N);
}

float->float pipeline IFFTKernel4(int B, int FFTDataParallelism) {
  int N = B;

  add FFTReorder(N);
  add Fused_CombineDFT(N);
}

float->float pipeline Fused_CombineDFT(int N){
    int m = 2;
    int j = 2;
    add MySplit(j, m);
    add CombineDFT1(m);
    for(; j < N; j *= 2){
      add Fused_MyJoin_MySplit3(j, j*2, m);
      add CombineDFT2(m);
    }
    add MyJoin(j, m);
}

float->float filter PassF(){
   work pop 1 push 1{
    push(pop());
  }
}

float->float filter Fused_MyJoin_MySplit3(int n2, int n1, int m){
  work push 2*n1 pop 2*n1{
    for(int i = 0; i < n2; i++)
      push(pop());
    for(int i = 0; i < n2; i++)
      push(peek(i + n2));
    for(int i = 0; i < n2; i++)
      push(pop());
    for(int i = 0; i < n2; i++)
      pop();
    for(int i = 0; i < n2; i++)
      push(pop());
  }
}

float->float filter MyJoin(int n, int m){
  work pop 2 * n push 2 * n{
    float[n] tmp;
    int id = 0;
    for(int i = 0; i < n/m; i++){
      for(int j = 0; j < m; j++)
        push(pop());
      for(int j = 0; j < m; j++)
        tmp[id++] = pop();
    }

    for(int i = 0; i < n; i++)
      push(tmp[i]);
  }
}

float->float filter MySplit(int n, int m){
  work pop 2 * n push 2 * n{
    for(int i = 0; i < n/m; i++){
      for(int j = 0; j < m; j++){
        push(pop());
      }
      for(int j = n - m; j < n; j++){
        push(peek(j));
      }
    }
    for(int i = 0; i < n; i++)
      pop();
  }
}


float->float filter CombineDFT2(int n) {

  float wn_r, wn_i;

  init {
    wn_r = (float)cos(2 * 3.141592654 / n);
    wn_i = (float)sin(2 * 3.141592654 / n);
  }

  work push 2*n pop 2*n {
    int i;
    float w_r = 1;
    float w_i = 0;
    float[2*n] results;
    float[2*n] data;
    for(i = 0; i < 2*n; i++)
      data[i] = pop();

    for (i = 0; i < n; i += 2)
    {
      float y0_r = data[i];
      float y0_i = data[i+1];

      float y1_r = data[n + i];
      float y1_i = data[n + i + 1];

      float y1w_r = y1_r * w_r - y1_i * w_i;
      float y1w_i = y1_r * w_i + y1_i * w_r;

      results[i] = y0_r + y1w_r;
      results[i + 1] = y0_i + y1w_i;

      results[n + i] = y0_r - y1w_r;
      results[n + i + 1] = y0_i - y1w_i;

      float w_r_next = w_r * wn_r - w_i * wn_i;
      float w_i_next = w_r * wn_i + w_i * wn_r;
      w_r = w_r_next;
      w_i = w_i_next;
    }

    for (i = 0; i < 2 * n; i++){
      push(results[i]);
    }
  }
}












float->float filter PassF(){
	work pop 1 push 1{
		push(pop());
	}
}

float->void filter DropF(){
	work pop 1{
		pop();
	}
}

void->float filter GenF(){
	work push 1{
		push(0);
	}
}

float->float splitjoin Contract(int N, int B){
	split roundrobin(2*N, 2*(B-N));
	add PassF();
	add DropF();
	join roundrobin(2*N, 0);
}

/*
float->float filter Contract(int N, int B) {
    float x;
    work pop 2*B push 2*N {
	  for (int i = 0; i < 2*N; i++) {
		push(pop());
	  }
	  for (int i = 2*N; i < 2*B; i++) {
		pop(); 
	  }
    }
}
*/

float->float splitjoin Expand(int N, int B){
	split roundrobin(2*N, 0);
	add PassF();
	add GenF();
	join roundrobin(2*N, 2*(B-N));
}

/*
// expand data for next-largest power of 2 (known to be 64)
float->float filter Expand(int N, int B) {
    work pop 2*N push 2*B {
	  for (int i = 0; i < 2*N; i++) {
		float x = pop();
		push(x);
	  }
	  for (int i = 2*N; i < 2*B; i++) {
		push(0.0);
	  }
    }
}
*/

// Multiply data by coefficients: in this case, we have constant
// coefficients with 0.0 imaginary part, allowing simplification.

// float->float filter Multiply(int B) {
//     
//     float[B][2] coeff;
// 
//     init {
// 	  for (int i = 0; i<B; i++) {
// 		coeff[i][0] = 0.00390625;
// 		coeff[i][1] = 0.0;
// 	  }
//     }
//     
//     work pop 2*B push 2*B { 
// 	  for (int j = 0; j < B; j++) {
// 		// get in1
// 		float real1 = pop();
// 		float imag1 = pop();
// 		// get in2
// 		float real2 = coeff[j][0];
// 		float imag2 = coeff[j][1];
// 		// compute product
// 		float real3 = real1*real2 - imag1*imag2;
// 		float imag3 = real1*imag2 + imag1*real2;
// 		// push
// 		push(real3);
// 		push(imag3);
// 	  }
//     }
// }


// Simplified multiply by a constant.
// 
float->float filter Multiply_by_float(int B, float m) {
	work pop 8 push 8 { 
		for (int j = 0; j < 8; j++) {
			push(pop() * m);
		}
	}
}

// Transpose written as a filter.
// A future optimization could be to combine Transpose with source.
//
// The Transpose at the end can be eliminated if you are going on to
// other phases of the GMTI program with this data and can masage their
// data requirements appropriately.
float->float filter Transpose(int M, int N) {
	work push M*N*2 peek M*N*2 pop M*N*2 {
		for(int i=0; i<M; i++) {
			for(int j=0; j<N; j++) {
				push(peek(i*N*2+j*2));
				push(peek(i*N*2+j*2+1));
			}
		}
		for(int i=0; i<M; i++) {
			for(int j=0; j<N; j++) {
				pop();
				pop();
			}
		}
	}
}
/*
float->float filter Transpose(int M, int N) {
	work pop 8 push 8{
		for(int i = 0; i < 8; i++)
			push(pop());
	}
}*/

/*
float->float filter Transpose(int M, int N) {
    work push M*N*2 peek M*N*2 pop M*N*2 {
        for(int i=0; i<M; i++) {
            for(int j=0; j<N; j++) {
                push(peek(i*N*2+j*2));
                push(peek(i*N*2+j*2+1));
            }
        }
        for(int i=0; i<M; i++) {
            for(int j=0; j<N; j++) {
                pop();
                pop();
            }
        }
    }
}
*/

float->void filter sink (int m) {

	float x, diff;
	int correct = 1;

	work pop 36 * 2 * m { 
		for (int i=0; i<m; i++) {
			for (int j=0; j<36; j++) {
// For self-checking generated inputs.
//           x = pop();
//           diff = x - j;
//           if(diff<0)
//             diff *= -1;
//           if(diff > 0.01)
//             correct = 0;
//           x = pop();
//           diff = x - j - 100;
//           if(diff<0)
//             diff *= -1;
//           if(diff > 0.01)
//             correct = 0;

// For printing outputs instead of self-checking.
// (Needed if not self-generated inputs, unless you want all of refeq.c's
//  contents to check against.)
				println(pop());
				println(pop());
			}
		}
//    println(correct);
	}
}


// parameter m is number of (N * sizeof(complex)/sizeof(float)) 

/*****************************************************************************/
/*
 * N-way complex DFT / IDFT where N is a power of 2.
 *
 * The DFT algorithm is a relatively standard FFT with the complex numbers
 * represented as seqeunces floating-point numbers alternating real part with
 * imaginary part.
 *
 * The entry points to this algorithm are FFTKernel4 and IFFTKernel4
 * (For reasons best known to the original author of FFT2.str).
 * Both take parameters "n" a power of 2, which is the number of complex points
 * per DFT/IDFT, and "Dataparallelism" a parameter that may cause several
 * FFT/IFFT operations to be used in a splitjoin.
 * 
 */
/*****************************************************************************/


void->float filter PassID(int n, int m){
	work push n/m{
		int bound = n / m;
		for(int i = 0; i < bound; i++)
			push(i * m);
	}
}

float->float pipeline CombineDFT(int n){
	int m = n / 8;
	if(m < 2)
		m = n;
	if(m > 8)
		m = 8;

	add splitjoin{
		split roundrobin(0, n, n);
		add PassID(n, m);
		add PassF();
		add PassF();
		join roundrobin(1, m, m);
	}
	add CombineDFT1(m, n);
	add splitjoin{
		split roundrobin(m, m);
		add PassF();
		add PassF();
		join roundrobin(n, n);
	}
}

float->float filter CombineDFT1(int n, int on) {

  // coefficients, real and imaginary interleaved
	float[on] w;

	init {
		float wn_r = (float)cos(2 * 3.141592654 / on);
		float wn_i = (float)sin(-2 * 3.141592654 / on);
		float real = 1;
		float imag = 0;
		float next_real, next_imag;
		for (int i=0; i<on; i+=2) {
			w[i] = real;
			w[i+1] = imag;
			next_real = real * wn_r - imag * wn_i;
			next_imag = real * wn_i + imag * wn_r;
			real = next_real;
			imag = next_imag;
		}
	}

	work push 2*n pop 2*n+1 {
		int i;
		float[2*n] results;
		int offset = (int)pop();

		for (i = 0; i < n; i += 2)
		{
			int i_plus_1 = i+1;

			float y0_r = peek(i);
			float y0_i = peek(i_plus_1);

			float y1_r = peek(n + i);
			float y1_i = peek(n + i_plus_1);

	    // load into temps to make sure it doesn't got loaded
	    // separately for each load
			float weight_real = w[i + offset];
			float weight_imag = w[i_plus_1 + offset];

			float y1w_r = y1_r * weight_real - y1_i * weight_imag;
			float y1w_i = y1_r * weight_imag + y1_i * weight_real;

			results[i] = y0_r + y1w_r;
			results[i + 1] = y0_i + y1w_i;

			results[n + i] = y0_r - y1w_r;
			results[n + i + 1] = y0_i - y1w_i;
		}

		for (i = 0; i < 2 * n; i++)
		{
			pop();
			push(results[i]);
		}
	}
}

/*
float->float pipeline CombineIDFT(int n){
	int m = 2;
	add splitjoin{
		split roundrobin(0, n, n);
		add PassID(n, m);
		add PassF();
		add PassF();
		join roundrobin(1, m, m);
	}
	add CombineIDFT1(m, n);
  add splitjoin{
    split roundrobin(m, m);
    add PassF();
    add PassF();
    join roundrobin(n, n);
  }
}

float->float filter CombineIDFT1(int n, int on) {

  // coefficients, real and imaginary interleaved
  float[on] w;

  init {
      float wn_r = (float)cos(2 * 3.141592654 / on);
      float wn_i = (float)sin(2 * 3.141592654 / on);
      float real = 1;
      float imag = 0;
      float next_real, next_imag;
      for (int i=0; i<on; i+=2) {
	  w[i] = real;
	  w[i+1] = imag;
	  next_real = real * wn_r - imag * wn_i;
	  next_imag = real * wn_i + imag * wn_r;
	  real = next_real;
	  imag = next_imag;
      }
  }

  work push 2*n pop 2*n+1 {
  	int i;
  	float[2*n] results;
  	int offset = (int)pop();

  	for (i = 0; i < n; i += 2)
  	{
  		int i_plus_1 = i+1;

  		float y0_r = peek(i);
  		float y0_i = peek(i_plus_1);

  		float y1_r = peek(n + i);
  		float y1_i = peek(n + i_plus_1);

	    // load into temps to make sure it doesn't got loaded
	    // separately for each load
  		float weight_real = w[i + offset];
  		float weight_imag = w[i_plus_1 + offset];

  		float y1w_r = y1_r * weight_real - y1_i * weight_imag;
  		float y1w_i = y1_r * weight_imag + y1_i * weight_real;

  		results[i] = y0_r + y1w_r;
  		results[i + 1] = y0_i + y1w_i;

  		results[n + i] = y0_r - y1w_r;
  		results[n + i + 1] = y0_i - y1w_i;
  	}

  	for (i = 0; i < 2 * n; i++)
  	{
  		pop();
  		push(results[i]);
  	}
  }
}

float->float pipeline CombineIDFTFinal(int n){
	int m = 2;
	add splitjoin{
		split roundrobin(0, n, n);
		add PassID(n, m);
		add PassF();
		add PassF();
		join roundrobin(1, m, m);
	}
	add CombineIDFTFinal1(m, n);
  add splitjoin{
    split roundrobin(m, m);
    add PassF();
    add PassF();
    join roundrobin(n, n);
  }
}

float->float filter CombineIDFTFinal1(int n, int on) {

  // coefficients, real and imaginary interleaved
  float[on] w;
  float n_recip;

  init {
      float wn_r = (float)cos(2 * 3.141592654 / on);
      float wn_i = (float)sin(2 * 3.141592654 / on);
      n_recip = 1.0/((float)on);
      // scales coefficients for y1 (but not y0)
      float real = n_recip;
      float imag = 0;
      float next_real, next_imag;
      for (int i=0; i<on; i+=2) {
	  w[i] = real;
	  w[i+1] = imag;
	  next_real = real * wn_r - imag * wn_i;
	  next_imag = real * wn_i + imag * wn_r;
	  real = next_real;
	  imag = next_imag;
      }
  }

  work push 2*n pop 2*n+1 {
  	int i;
  	float[2*n] results;
  	int offset = (int)pop();

  	for (i = 0; i < n; i += 2)
  	{
  		int i_plus_1 = i+1;

  		float y0_r = peek(i);
  		float y0_i = peek(i_plus_1);

  		float y1_r = peek(n + i);
  		float y1_i = peek(n + i_plus_1);

	    // load into temps to make sure it doesn't got loaded
	    // separately for each load
  		float weight_real = w[i + offset];
  		float weight_imag = w[i_plus_1 + offset];

  		float y1w_r = y1_r * weight_real - y1_i * weight_imag;
  		float y1w_i = y1_r * weight_imag + y1_i * weight_real;

  		results[i] = y0_r + y1w_r;
  		results[i + 1] = y0_i + y1w_i;

  		results[n + i] = y0_r - y1w_r;
  		results[n + i + 1] = y0_i - y1w_i;
  	}

  	for (i = 0; i < 2 * n; i++)
  	{
  		pop();
  		push(results[i]);
  	}
  }
}
*/

/*
float->float filter CombineDFT(int n) {

  // coefficients, real and imaginary interleaved
  float[n] w;

  init {
      float wn_r = (float)cos(2 * 3.141592654 / n);
      float wn_i = (float)sin(-2 * 3.141592654 / n);
      float real = 1;
      float imag = 0;
      float next_real, next_imag;
      for (int i=0; i<n; i+=2) {
	  w[i] = real;
	  w[i+1] = imag;
	  next_real = real * wn_r - imag * wn_i;
	  next_imag = real * wn_i + imag * wn_r;
	  real = next_real;
	  imag = next_imag;
      }
  }

  work push 2*n pop 2*n {
        int i;
	float[2*n] results;

        for (i = 0; i < n; i += 2)
        {
	    int i_plus_1 = i+1;

	    float y0_r = peek(i);
            float y0_i = peek(i_plus_1);
            
	    float y1_r = peek(n + i);
            float y1_i = peek(n + i_plus_1);

	    // load into temps to make sure it doesn't got loaded
	    // separately for each load
	    float weight_real = w[i];
	    float weight_imag = w[i_plus_1];

            float y1w_r = y1_r * weight_real - y1_i * weight_imag;
            float y1w_i = y1_r * weight_imag + y1_i * weight_real;

            results[i] = y0_r + y1w_r;
            results[i + 1] = y0_i + y1w_i;

	    results[n + i] = y0_r - y1w_r;
            results[n + i + 1] = y0_i - y1w_i;
        }

        for (i = 0; i < 2 * n; i++)
        {
            pop();
            push(results[i]);
        }
    }

}
*/
float->float filter CombineIDFT(int n) {

  // coefficients, real and imaginary interleaved
	float[n] w;

	init {
		float wn_r = (float)cos(2 * 3.141592654 / n);
		float wn_i = (float)sin(2 * 3.141592654 / n);
		float real = 1;
		float imag = 0;
		float next_real, next_imag;
		for (int i=0; i<n; i+=2) {
			w[i] = real;
			w[i+1] = imag;
			next_real = real * wn_r - imag * wn_i;
			next_imag = real * wn_i + imag * wn_r;
			real = next_real;
			imag = next_imag;
		}
	}

	work push 2*n pop 2*n {
		int i;
		float[2*n] results;

		for (i = 0; i < n; i += 2)
		{
			int i_plus_1 = i+1;

			float y0_r = peek(i);
			float y0_i = peek(i_plus_1);

			float y1_r = peek(n + i);
			float y1_i = peek(n + i_plus_1);

	    // load into temps to make sure it doesn't got loaded
	    // separately for each load
			float weight_real = w[i];
			float weight_imag = w[i_plus_1];

			float y1w_r = y1_r * weight_real - y1_i * weight_imag;
			float y1w_i = y1_r * weight_imag + y1_i * weight_real;

			results[i] = y0_r + y1w_r;
			results[i + 1] = y0_i + y1w_i;

			results[n + i] = y0_r - y1w_r;
			results[n + i + 1] = y0_i - y1w_i;
		}

		for (i = 0; i < n; i++) {
			pop();
			pop();
		}

		for (i = 0; i < 2 * n; i+= 2) {
			push(results[i]);
			push(results[i+1]);
		}
	}

}
float->float filter CombineIDFTFinal(int n) {

  // coefficients, real and imaginary interleaved
	float[n] w;
	float n_recip;

	init {
		float wn_r = (float)cos(2 * 3.141592654 / n);
		float wn_i = (float)sin(2 * 3.141592654 / n);
		n_recip = 1.0/((float)n);
      // scales coefficients for y1 (but not y0)
		float real = n_recip;
		float imag = 0;
		float next_real, next_imag;
		for (int i=0; i<n; i+=2) {
			w[i] = real;
			w[i+1] = imag;
			next_real = real * wn_r - imag * wn_i;
			next_imag = real * wn_i + imag * wn_r;
			real = next_real;
			imag = next_imag;
		}
	}

	work push 2*n pop 2*n {
		int i;
		float[2*n] results;

		for (i = 0; i < n; i += 2)
		{
			int i_plus_1 = i+1;

	    // y0: extra mult to scale
			float y0_r = n_recip * peek(i);
			float y0_i = n_recip * peek(i_plus_1);

			float y1_r = peek(n + i);
			float y1_i = peek(n + i_plus_1);

	    // load into temps to make sure it doesn't got loaded
	    // separately for each load
			float weight_real = w[i];
			float weight_imag = w[i_plus_1];

			float y1w_r = y1_r * weight_real - y1_i * weight_imag;
			float y1w_i = y1_r * weight_imag + y1_i * weight_real;

			results[i] = y0_r + y1w_r;
			results[i + 1] = y0_i + y1w_i;

			results[n + i] = y0_r - y1w_r;
			results[n + i + 1] = y0_i - y1w_i;
		}

		for (i = 0; i < n; i++) {
			pop();
			pop();
		}

		for (i = 0; i < 2 * n; i+= 2) {
			push(results[i]);
			push(results[i+1]);
		}
	}

}



float->float splitjoin FFTReorderSimple(int n){
	split roundrobin(2, 2);
	add PassF();
	add PassF();
	join roundrobin(n, n);
}


float->float pipeline FFTReorder(int n) {

	for(int i=1; i<(n/2); i*= 2)
		add FFTReorderSimple(n/i);

}

/*
// N-way complex FFT where N is power of 2
float->float pipeline FFTKernel4(int n, int DataParallelism) {
	if (DataParallelism == 1) {
		add FFTReorder(n);
		for(int j=2; j<=n; j*=2) {
			add CombineDFT(j);
		}
	} else {
	// data-parallel version
		add float->float splitjoin {
			split roundrobin(2*n);
			for(int i=0; i<DataParallelism; i++) {
				add pipeline {
					add FFTReorder(n);
					for(int j=2; j<=n; j*=2) {
						add CombineDFT(j);
					}
				}
			}
			join roundrobin(2*n);
		}
	}
}

// N-way complex IFFT where N is power of 2
float->float pipeline IFFTKernel4(int n, int DataParallelism) {
	if (DataParallelism == 1) {
		add FFTReorder(n);
		for(int j=2; j<n; j*=2) {
			add CombineIDFT(j);
		}
		add CombineIDFTFinal(n);
	} else { 
		add float->float splitjoin {
			split roundrobin(2*n);
			for(int i=0; i<DataParallelism; i++) {    
				add pipeline {
					add FFTReorder(n);
					for(int j=2; j<n; j*=2) {
						add CombineIDFT(j);
					}
					add CombineIDFTFinal(n);
				}
			}
			join roundrobin(2*n);
		}
	}
}
*/

